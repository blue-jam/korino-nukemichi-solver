<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Åì„Åä„Çä„ÅÆ„Å¨„Åë„Åø„Å°„ÇΩ„É´„Éê„Éº (Sliding Floor Puzzle Solver)</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-symbol {
            font-family: monospace;
            font-size: 1.2em;
            font-weight: bold;
            padding: 5px 10px;
            background: white;
            border-radius: 5px;
            border: 2px solid #ddd;
        }

        textarea {
            width: 100%;
            min-height: 150px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            resize: vertical;
            line-height: 1.5;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        #result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }

        #result.success {
            background: #d4edda;
            border: 2px solid #c3e6cb;
            color: #155724;
        }

        #result.error {
            background: #f8d7da;
            border: 2px solid #f5c6cb;
            color: #721c24;
        }

        .grid-container {
            display: inline-block;
            border: 3px solid #333;
            background: #fff;
            margin: 20px 0;
        }

        .grid-row {
            display: flex;
        }

        .grid-cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            border: 1px solid #ccc;
            transition: all 0.3s ease;
        }

        .grid-cell.wall {
            background: #333;
            color: white;
        }

        .grid-cell.floor {
            background: #e9ecef;
        }

        .grid-cell.ice {
            background: #b8e0f6;
            color: #0066cc;
        }

        .grid-cell.start {
            background: #28a745;
            color: white;
        }

        .grid-cell.goal {
            background: #ffc107;
            color: #333;
        }

        .grid-cell.player {
            background: #007bff;
            color: white;
            animation: pulse 1s infinite;
        }

        .grid-cell.path {
            background: #ffeb3b;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }

        .arrow-buttons {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
        }

        .arrow-btn {
            width: 60px;
            height: 60px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .arrow-btn:hover:not(:disabled) {
            background: #5568d3;
            transform: scale(1.05);
        }

        .arrow-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .arrow-btn.up { grid-column: 2; grid-row: 1; }
        .arrow-btn.left { grid-column: 1; grid-row: 2; }
        .arrow-btn.right { grid-column: 3; grid-row: 2; }
        .arrow-btn.down { grid-column: 2; grid-row: 3; }

        .game-status {
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .game-status.won {
            color: #28a745;
        }

        .example-puzzles {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .example-puzzle {
            flex: 1;
            min-width: 200px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .example-puzzle:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }

        .example-puzzle h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #667eea;
        }

        .example-puzzle pre {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üßä „Åì„Åä„Çä„ÅÆ„Å¨„Åë„Åø„Å°„ÇΩ„É´„Éê„Éº</h1>
        <p class="subtitle">Sliding Floor Puzzle Solver</p>

        <div class="section">
            <h2>üìù „Éë„Ç∫„É´ÂÖ•Âäõ (Puzzle Input)</h2>
            
            <div class="legend">
                <div class="legend-item">
                    <span class="legend-symbol">#</span>
                    <span>Â£Å„ÉªÂ≤© (Wall/Rock)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">_</span>
                    <span>Êªë„ÇãÂ∫ä (Ice/Sliding Floor)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">.</span>
                    <span>ÊôÆÈÄö„ÅÆÂ∫ä (Normal Floor)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">S</span>
                    <span>„Çπ„Çø„Éº„Éà (Start)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">G</span>
                    <span>„Ç¥„Éº„É´ (Goal)</span>
                </div>
            </div>

            <div class="example-puzzles" id="examplePuzzles">
                <!-- Examples will be loaded by JavaScript -->
            </div>

            <textarea id="puzzleInput" placeholder="„Éë„Ç∫„É´„ÅÆ„Ç∞„É™„ÉÉ„Éâ„Çí„Åì„Åì„Å´ÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ...">#####
#S__#
#.#.#
#__G#
#####</textarea>

            <div class="button-group">
                <button class="btn-primary" onclick="solvePuzzle()">üîç Ëß£„Åè (Solve)</button>
                <button class="btn-secondary" onclick="clearInput()">üóëÔ∏è „ÇØ„É™„Ç¢ (Clear)</button>
            </div>

            <div id="result"></div>
            <div id="solutionVisualization"></div>
        </div>

        <div class="section">
            <h2>üéÆ ÊâãÂãï„Éó„É¨„Ç§ (Manual Play)</h2>
            <p style="margin-bottom: 15px;">Áü¢Âç∞„Éú„Çø„É≥„Åæ„Åü„ÅØ„Ç≠„Éº„Éú„Éº„Éâ„ÅÆÁü¢Âç∞„Ç≠„Éº„ÅßÁßªÂãï„Åß„Åç„Åæ„Åô„ÄÇ</p>
            
            <div style="display: flex; flex-direction: column; align-items: center;">
                <div id="manualGrid"></div>
                <div class="controls">
                    <div class="arrow-buttons">
                        <button class="arrow-btn up" onclick="movePlayer('up')">‚Üë</button>
                        <button class="arrow-btn left" onclick="movePlayer('left')">‚Üê</button>
                        <button class="arrow-btn right" onclick="movePlayer('right')">‚Üí</button>
                        <button class="arrow-btn down" onclick="movePlayer('down')">‚Üì</button>
                    </div>
                    <button class="btn-success" onclick="resetManualGame()">üîÑ „É™„Çª„ÉÉ„Éà (Reset)</button>
                    <div class="game-status" id="gameStatus"></div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üé≤ „É©„É≥„ÉÄ„É†ÁßªÂãï„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ (Random Walk Simulation)</h2>
            <p style="margin-bottom: 15px;">„É©„É≥„ÉÄ„É†„Å´ÁßªÂãï„Åó„ÅüÊôÇ„Å´„ÄÅ„Ç¥„Éº„É´„Åô„Çã„Åæ„Åß„ÅÆ„Çø„Éº„É≥Êï∞„ÅÆÂπ≥Âùá„ÇíË®àÁÆó„Åó„Åæ„Åô„ÄÇ</p>
            
            <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 15px;">
                <div>
                    <label for="simTime" style="display: block; margin-bottom: 5px;">„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÊôÇÈñìÔºàÁßíÔºâ:</label>
                    <input type="number" id="simTime" value="10" min="1" max="60" style="padding: 8px; border: 2px solid #ddd; border-radius: 5px; width: 120px;">
                </div>
                <div>
                    <label for="maxTurns" style="display: block; margin-bottom: 5px;">ÊúÄÂ§ß„Çø„Éº„É≥Êï∞:</label>
                    <input type="number" id="maxTurns" value="10000" min="100" max="100000" style="padding: 8px; border: 2px solid #ddd; border-radius: 5px; width: 120px;">
                </div>
            </div>

            <button class="btn-primary" onclick="runSimulation()">‚ñ∂Ô∏è „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÈñãÂßã (Start Simulation)</button>
            
            <div id="simulationResult" style="margin-top: 20px; padding: 15px; border-radius: 8px; display: none;"></div>
        </div>
    </div>

    <script>
        // Puzzle state
        let grid = [];
        let startPos = null;
        let goalPos = null;

        // Manual play state
        let manualGrid = [];
        let playerPos = null;
        let manualStartPos = null;
        let manualGoalPos = null;
        let gameWon = false;

        // Example puzzles
        const examples = {
            1: `
##################
#_____________####
#______________###
#_______________##
#___#___________.#
#_______________G#
#_____#_________.#
#__________#____##
#____#__________##
#_______________##
#______________###
#_________#_____##
#__#____________##
#_____#_________##
#_______________##
###############S##
##################`.trim(),
            2: `
#############
##_#_______##
##_________G#
##_________##
#S_______#_.#
#.#___#____##
#############`.trim(),
            3: `
###########
#####S.####
#__#______#
#_____#___#
#_________#
#________##
#___#_____#
#______#__#
#_#_______#
#_________#
#####_____#
######.#G##
###########`.trim(),
            4: `
###########
#####G.####
#__#______#
#_____#___#
#_________#
#________##
#___#_____#
#______#__#
#_#_______#
#_________#
#####_____#
######.#S##
###########`.trim(),
        };

        function loadExample(num) {
            document.getElementById('puzzleInput').value = examples[num];
        }

        // Load example puzzles into HTML
        function loadExamplePuzzles() {
            const container = document.getElementById('examplePuzzles');
            const exampleTitles = {
                1: '‰æã1',
                2: '‰æã2',
                3: '‰æã3',
                4: '‰æã4',
            };
            
            let html = '';
            for (let i = 1; i <= 4; i++) {
                html += `<div class="example-puzzle" onclick="loadExample(${i})">
                    <h3>${exampleTitles[i]}</h3>
                    <pre>${examples[i]}</pre>
                </div>`;
            }
            container.innerHTML = html;
        }

        function parseGrid(input) {
            const lines = input.trim().split('\n');
            const parsedGrid = [];
            let start = null;
            let goal = null;

            for (let row = 0; row < lines.length; row++) {
                const gridRow = [];
                for (let col = 0; col < lines[row].length; col++) {
                    const char = lines[row][col];
                    gridRow.push(char);
                    if (char === 'S') start = { row, col };
                    if (char === 'G') goal = { row, col };
                }
                parsedGrid.push(gridRow);
            }

            return { grid: parsedGrid, start, goal };
        }

        function isValidMove(grid, pos) {
            if (pos.row < 0 || pos.row >= grid.length) return false;
            if (pos.col < 0 || pos.col >= grid[0].length) return false;
            return grid[pos.row][pos.col] !== '#';
        }

        function move(grid, pos, direction) {
            const directions = {
                'up': { row: -1, col: 0 },
                'down': { row: 1, col: 0 },
                'left': { row: 0, col: -1 },
                'right': { row: 0, col: 1 }
            };

            const delta = directions[direction];
            let newPos = { row: pos.row, col: pos.col };
            let nextPos = { row: pos.row + delta.row, col: pos.col + delta.col };

            if (!isValidMove(grid, nextPos)) return null;

            // Check if the next cell is ice
            const nextCell = grid[nextPos.row][nextPos.col];

            // Move to the next position
            newPos = { ...nextPos };

            // If on ice, keep sliding
            if (nextCell === '_') {
                while (true) {
                    const slidePos = {
                        row: newPos.row + delta.row,
                        col: newPos.col + delta.col
                    };
                    
                    if (!isValidMove(grid, slidePos)) break;
                    
                    newPos = slidePos;
                    const slideCell = grid[slidePos.row][slidePos.col];
                    
                    // Stop if we hit a non-ice cell (including goal)
                    if (slideCell !== '_') break;
                }
            }

            return newPos;
        }

        function solvePuzzle() {
            const input = document.getElementById('puzzleInput').value;
            const resultDiv = document.getElementById('result');
            const visualizationDiv = document.getElementById('solutionVisualization');
            
            if (!input.trim()) {
                showResult('„Éë„Ç∫„É´„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', 'error');
                return;
            }

            try {
                const { grid: parsedGrid, start, goal } = parseGrid(input);
                
                if (!start || !goal) {
                    showResult('„Çπ„Çø„Éº„Éà(S)„Å®„Ç¥„Éº„É´(G)„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', 'error');
                    return;
                }

                grid = parsedGrid;
                startPos = start;
                goalPos = goal;

                const solution = bfsSolve(parsedGrid, start, goal);

                if (solution) {
                    const directionString = solution.directions.map(d => {
                        const dirMap = { 'up': 'U', 'down': 'D', 'left': 'L', 'right': 'R' };
                        return dirMap[d];
                    }).join('');
                    
                    // Calculate expected value
                    const expectedValue = calculateExpectedValue(parsedGrid, start, goal);
                    let resultMessage = `‚úÖ Ëß£Ê±∫„Åó„Åæ„Åó„ÅüÔºÅ ${solution.path.length - 1} Êâã„ÅßÂà∞ÈÅîÂèØËÉΩ„Åß„Åô„ÄÇÁµåË∑Ø: ${directionString}.`;
                    if (expectedValue !== null) {
                        resultMessage += `\n\n„É©„É≥„ÉÄ„É†ÁßªÂãï„Åß„Ç¥„Éº„É´„Åæ„Åß„ÅÆÊúüÂæÖ„Çø„Éº„É≥Êï∞: ${expectedValue.toFixed(2)}`;
                    } else {
                        resultMessage += `\n\n„É©„É≥„ÉÄ„É†ÁßªÂãï„Åß„Ç¥„Éº„É´„Åæ„Åß„ÅÆÊúüÂæÖ„Çø„Éº„É≥Êï∞„ÇíË®àÁÆó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ`;
                    }
                    
                    showResult(resultMessage, 'success');
                    visualizeSolution(parsedGrid, solution.path, solution.directions);
                    
                    // Also set up manual play
                    setupManualGame(parsedGrid, start, goal);
                } else {
                    showResult('‚ùå „Åì„ÅÆ„Éë„Ç∫„É´„ÅØËß£„Åë„Åæ„Åõ„Çì„ÄÇ', 'error');
                    visualizationDiv.innerHTML = '';
                }
            } catch (error) {
                showResult('„Ç®„É©„Éº: ' + error.message, 'error');
            }
        }

        // ÂπÖÂÑ™ÂÖàÊé¢Á¥¢„ÅßËø∑Ë∑Ø„ÇíËß£„Åç„ÄÅÁ≠î„Åà„Çí{ path, directions }„Å®„Åó„Å¶Ëøî„Åô„ÄÇ
        // „Åü„Å†„Åó„ÄÅpath„ÅØÈÄî‰∏≠„ÅßÈÄö„Çã„Éû„ÇπÔºà{row, col}Ôºâ„ÅÆ„É™„Çπ„Éà„ÄÅ
        // directions„ÅØÊñπÂêë(`up`, `down`, `left`, `right`)„ÅÆ„É™„Çπ„Éà
        // Ëß£„Åë„Å™„ÅÑÂ†¥Âêà„ÅØnull„ÇíËøî„Åô„ÄÇ
        function bfsSolve(grid, start, goal) {
            const queue = [start];
            const previous = new Map();
            previous.set(`(${start.row},${start.col})`, { position: null, direction: null });
            
            const directions = ['up', 'left', 'down', 'right'];

            while (queue.length > 0) {
                const current = queue.shift();
                if (current.row === goal.row && current.col === goal.col) {
                    break;
                }
                for (const d of directions) {
                    const nextPos = move(grid, current, d);
                    if (!nextPos) {
                        continue;
                    }
                    const s = `(${nextPos.row},${nextPos.col})`;
                    if (previous.has(s)) {
                        continue;
                    }
                    previous.set(s, { position: current, direction: d });
                    queue.push(nextPos);
                }
            }

            let s = `(${goal.row},${goal.col})`;
            if (!previous.has(s)) {
                return null;
            }

            const path = [goal];
            const dirs = [];
            for (;;) {
                const { position, direction } = previous.get(s);
                if (!position) {
                    break;
                }
                path.push(position);
                dirs.push(direction);
                s = `(${position.row},${position.col})`;
            }
            path.reverse();
            dirs.reverse();

            return { path, directions: dirs };
        }

        function showResult(message, type) {
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = message;
            resultDiv.className = type;
            resultDiv.style.display = 'block';
        }

        function visualizeSolution(grid, path, directions) {
            const visualizationDiv = document.getElementById('solutionVisualization');
            const pathSet = new Set(path.map(p => `${p.row},${p.col}`));
            
            let html = '<div class="grid-container">';
            for (let row = 0; row < grid.length; row++) {
                html += '<div class="grid-row">';
                for (let col = 0; col < grid[row].length; col++) {
                    const cell = grid[row][col];
                    let cellClass = 'grid-cell';
                    let cellContent = cell;

                    if (cell === '#') cellClass += ' wall';
                    else if (cell === '.') cellClass += ' floor';
                    else if (cell === '_') cellClass += ' ice';
                    else if (cell === 'S') cellClass += ' start';
                    else if (cell === 'G') cellClass += ' goal';

                    if (pathSet.has(`${row},${col}`) && cell !== 'S' && cell !== 'G') {
                        cellClass += ' path';
                    }

                    html += `<div class="${cellClass}">${cellContent}</div>`;
                }
                html += '</div>';
            }
            html += '</div>';

            visualizationDiv.innerHTML = html;
        }

        function clearInput() {
            document.getElementById('puzzleInput').value = '';
            document.getElementById('result').style.display = 'none';
            document.getElementById('solutionVisualization').innerHTML = '';
        }

        // Manual play functions
        function setupManualGame(grid, start, goal) {
            manualGrid = grid.map(row => [...row]);
            manualStartPos = { ...start };
            manualGoalPos = { ...goal };
            playerPos = { ...start };
            gameWon = false;
            renderManualGrid();
            updateGameStatus();
        }

        function resetManualGame() {
            if (manualStartPos) {
                playerPos = { ...manualStartPos };
                gameWon = false;
                renderManualGrid();
                updateGameStatus();
            } else {
                // Try to set up from current input
                const input = document.getElementById('puzzleInput').value;
                if (input.trim()) {
                    try {
                        const { grid: parsedGrid, start, goal } = parseGrid(input);
                        if (start && goal) {
                            setupManualGame(parsedGrid, start, goal);
                        }
                    } catch (error) {
                        alert('„Éë„Ç∫„É´„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    }
                }
            }
        }

        function renderManualGrid() {
            const gridDiv = document.getElementById('manualGrid');
            
            if (!manualGrid.length) {
                gridDiv.innerHTML = '<p>„Éë„Ç∫„É´„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ</p>';
                return;
            }

            let html = '<div class="grid-container">';
            for (let row = 0; row < manualGrid.length; row++) {
                html += '<div class="grid-row">';
                for (let col = 0; col < manualGrid[row].length; col++) {
                    const cell = manualGrid[row][col];
                    let cellClass = 'grid-cell';
                    let cellContent = cell;

                    const isPlayer = playerPos && playerPos.row === row && playerPos.col === col;
                    const isGoal = manualGoalPos && manualGoalPos.row === row && manualGoalPos.col === col;

                    if (isPlayer) {
                        cellClass += ' player';
                        cellContent = 'P';
                    } else if (isGoal) {
                        cellClass += ' goal';
                        cellContent = 'G';
                    } else if (cell === '#') {
                        cellClass += ' wall';
                    } else if (cell === '.') {
                        cellClass += ' floor';
                    } else if (cell === '_') {
                        cellClass += ' ice';
                    } else if (cell === 'S') {
                        cellClass += ' start';
                    }

                    html += `<div class="${cellClass}">${cellContent}</div>`;
                }
                html += '</div>';
            }
            html += '</div>';

            gridDiv.innerHTML = html;
        }

        function movePlayer(direction) {
            if (gameWon || !playerPos) return;

            const newPos = move(manualGrid, playerPos, direction);
            
            if (newPos) {
                playerPos = newPos;
                renderManualGrid();
                
                if (playerPos.row === manualGoalPos.row && playerPos.col === manualGoalPos.col) {
                    gameWon = true;
                }
                updateGameStatus();
            }
        }

        function updateGameStatus() {
            const statusDiv = document.getElementById('gameStatus');
            if (gameWon) {
                statusDiv.textContent = 'üéâ „Ç¥„Éº„É´ÔºÅ„Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅ';
                statusDiv.className = 'game-status won';
            } else if (playerPos) {
                statusDiv.textContent = 'Áü¢Âç∞„Ç≠„Éº„ÅßÁßªÂãï„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
                statusDiv.className = 'game-status';
            } else {
                statusDiv.textContent = '';
                statusDiv.className = 'game-status';
            }
        }

        // Solve system of linear equations using Gaussian elimination with partial pivoting
        function solveLinearSystem(A, b) {
            const n = A.length;
            // Create augmented matrix
            const augmented = A.map((row, i) => [...row, b[i]]);
            console.log('Êã°Â§ß‰øÇÊï∞Ë°åÂàó', augmented);
            
            // Forward elimination with partial pivoting
            for (let col = 0; col < n; col++) {
                // Find pivot
                let maxRow = col;
                for (let row = col + 1; row < n; row++) {
                    if (Math.abs(augmented[row][col]) > Math.abs(augmented[maxRow][col])) {
                        maxRow = row;
                    }
                }
                
                // Swap rows
                [augmented[col], augmented[maxRow]] = [augmented[maxRow], augmented[col]];
                
                // Check for singular matrix
                if (Math.abs(augmented[col][col]) < 1e-10) {
                    continue; // Skip if pivot is too small
                }
                
                // Eliminate column
                for (let row = col + 1; row < n; row++) {
                    const factor = augmented[row][col] / augmented[col][col];
                    for (let j = col; j <= n; j++) {
                        augmented[row][j] -= factor * augmented[col][j];
                    }
                }
            }
            console.log('Ê∂àÂéªÊ≥ïÂæå„ÅÆÊã°Â§ß‰øÇÊï∞Ë°åÂàó', augmented);
            
            // Back substitution
            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                if (Math.abs(augmented[i][i]) < 1e-10) {
                    if (Math.abs(augmented[i][n]) > 1e-10) {
                        x[i] = NaN; // No solution
                    } else {
                        x[i] = 0; // If pivot is too small, assume solution is 0
                    }
                    continue;
                }
                x[i] = augmented[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= augmented[i][j] * x[j];
                }
                x[i] /= augmented[i][i];
            }
            
            return x;
        }

        // Calculate expected value using linear equations
        function calculateExpectedValue(grid, start, goal) {
            try {
                // Build state space - all reachable positions
                const states = [];
                const stateMap = new Map();
                const queue = [start];
                const visited = new Set([`${start.row},${start.col}`]);
                
                while (queue.length > 0) {
                    const pos = queue.shift();
                    const key = `${pos.row},${pos.col}`;
                    stateMap.set(key, states.length);
                    states.push(pos);
                    
                    // Skip goal state (absorbing state)
                    if (pos.row === goal.row && pos.col === goal.col) {
                        continue;
                    }
                    
                    // Find valid moves from this position
                    const directions = ['up', 'down', 'left', 'right'];
                    for (const dir of directions) {
                        const nextPos = move(grid, pos, dir);
                        if (nextPos) {
                            const nextKey = `${nextPos.row},${nextPos.col}`;
                            if (!visited.has(nextKey)) {
                                visited.add(nextKey);
                                queue.push(nextPos);
                            }
                        }
                    }
                }
                
                const n = states.length;
                const goalIdx = stateMap.get(`${goal.row},${goal.col}`);
                
                if (goalIdx === undefined) {
                    return null; // Goal not reachable
                }
                
                // Build system of linear equations: E[i] = 1 + sum(P[i][j] * E[j])
                // Rearrange to: E[i] - sum(P[i][j] * E[j]) = 1
                // For goal state: E[goal] = 0
                
                // Build coefficient matrix A and constant vector b
                const A = [];
                const b = [];
                
                for (let i = 0; i < n; i++) {
                    const pos = states[i];
                    const row = Array(n).fill(0);
                    
                    if (i === goalIdx) {
                        // Goal state: E[goal] = 0
                        row[i] = 1;
                        b.push(0);
                    } else {
                        // Non-goal state: E[i] - sum(P[i][j] * E[j]) = 1
                        row[i] = 1;
                        
                        // Find all valid moves and their probabilities
                        const directions = ['up', 'down', 'left', 'right'];
                        const validMoves = [];
                        
                        for (const dir of directions) {
                            const nextPos = move(grid, pos, dir);
                            if (nextPos) {
                                validMoves.push(nextPos);
                            }
                        }
                        
                        if (validMoves.length > 0) {
                            const prob = 1.0 / validMoves.length;
                            for (const nextPos of validMoves) {
                                const nextKey = `${nextPos.row},${nextPos.col}`;
                                const nextIdx = stateMap.get(nextKey);
                                row[nextIdx] -= prob;
                            }
                        }
                        
                        b.push(1);
                    }
                    
                    A.push(row);
                }
                
                // Solve using Gaussian elimination
                const solution = solveLinearSystem(A, b);
                const startIdx = stateMap.get(`${start.row},${start.col}`);
                
                return isNaN(solution[startIdx]) ? null : solution[startIdx];
            } catch (error) {
                console.error('Error calculating expected value:', error);
                return null;
            }
        }
        
        // Run random walk simulation
        function runSimulation() {
            const input = document.getElementById('puzzleInput').value;
            const simTimeSeconds = parseInt(document.getElementById('simTime').value);
            const maxTurns = parseInt(document.getElementById('maxTurns').value);
            const resultDiv = document.getElementById('simulationResult');
            
            if (!input.trim()) {
                resultDiv.textContent = '„Éë„Ç∫„É´„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
                resultDiv.style.background = '#f8d7da';
                resultDiv.style.border = '2px solid #f5c6cb';
                resultDiv.style.color = '#721c24';
                resultDiv.style.display = 'block';
                return;
            }
            
            try {
                const { grid: parsedGrid, start, goal } = parseGrid(input);
                
                if (!start || !goal) {
                    resultDiv.textContent = '„Çπ„Çø„Éº„Éà(S)„Å®„Ç¥„Éº„É´(G)„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
                    resultDiv.style.background = '#f8d7da';
                    resultDiv.style.border = '2px solid #f5c6cb';
                    resultDiv.style.color = '#721c24';
                    resultDiv.style.display = 'block';
                    return;
                }
                
                resultDiv.textContent = '„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÂÆüË°å‰∏≠...';
                resultDiv.style.background = '#d1ecf1';
                resultDiv.style.border = '2px solid #bee5eb';
                resultDiv.style.color = '#0c5460';
                resultDiv.style.display = 'block';
                
                // Run simulation asynchronously
                setTimeout(() => {
                    const startTime = Date.now();
                    let totalTurns = 0;
                    let successCount = 0;
                    let failCount = 0;
                    
                    while (Date.now() - startTime < simTimeSeconds * 1000) {
                        const result = simulateRandomWalk(parsedGrid, start, goal, maxTurns);
                        totalTurns += result.turns;
                        if (result.success) {
                            successCount++;
                        } else {
                            failCount++;
                        }
                    }
                    
                    if (successCount > 0) {
                        const avgTurns = totalTurns / (successCount + failCount);
                        resultDiv.innerHTML = `
                            <strong>‚úÖ „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÂÆå‰∫Ü</strong><br>
                            ÊàêÂäüÂõûÊï∞: ${successCount}<br>
                            Â§±ÊïóÂõûÊï∞: ${failCount}<br>
                            Âπ≥Âùá„Çø„Éº„É≥Êï∞: ${avgTurns.toFixed(2)}
                        `;
                        resultDiv.style.background = '#d4edda';
                        resultDiv.style.border = '2px solid #c3e6cb';
                        resultDiv.style.color = '#155724';
                    } else {
                        resultDiv.textContent = `‚ùå „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Â§±Êïó: ${failCount} Âõû„Åô„Åπ„Å¶ÊúÄÂ§ß„Çø„Éº„É≥Êï∞ ${maxTurns} „Å´Âà∞ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ`;
                        resultDiv.style.background = '#f8d7da';
                        resultDiv.style.border = '2px solid #f5c6cb';
                        resultDiv.style.color = '#721c24';
                    }
                }, 10);
                
            } catch (error) {
                resultDiv.textContent = '„Ç®„É©„Éº: ' + error.message;
                resultDiv.style.background = '#f8d7da';
                resultDiv.style.border = '2px solid #f5c6cb';
                resultDiv.style.color = '#721c24';
                resultDiv.style.display = 'block';
            }
        }
        
        // Simulate one random walk
        function simulateRandomWalk(grid, start, goal, maxTurns) {
            let pos = { ...start };
            let turns = 0;
            
            while (turns < maxTurns) {
                if (pos.row === goal.row && pos.col === goal.col) {
                    return { success: true, turns };
                }
                
                // Find valid moves
                const directions = ['up', 'down', 'left', 'right'];
                const validMoves = [];
                
                for (const dir of directions) {
                    const nextPos = move(grid, pos, dir);
                    if (nextPos) {
                        validMoves.push({ dir, pos: nextPos });
                    }
                }
                
                if (validMoves.length === 0) {
                    // No valid moves - stuck
                    return { success: false, turns };
                }
                
                // Choose random move
                const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                pos = randomMove.pos;
                turns++;
            }
            
            return { success: false, turns: maxTurns };
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            const keyMap = {
                'ArrowUp': 'up',
                'ArrowDown': 'down',
                'ArrowLeft': 'left',
                'ArrowRight': 'right'
            };

            if (keyMap[e.key]) {
                e.preventDefault();
                movePlayer(keyMap[e.key]);
            }
        });

        // Initialize with default puzzle for manual play
        window.addEventListener('load', () => {
            // Load example puzzles
            loadExamplePuzzles();
            
            const input = document.getElementById('puzzleInput').value;
            if (input) {
                try {
                    const { grid: parsedGrid, start, goal } = parseGrid(input);
                    if (start && goal) {
                        setupManualGame(parsedGrid, start, goal);
                    }
                } catch (error) {
                    // Ignore errors on initial load
                }
            }
        });
    </script>
</body>
</html>
